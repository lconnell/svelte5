/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Work Order App
 * OpenAPI spec version: 0.1.0
 */
import { createMutation, createQuery } from '@tanstack/svelte-query';
import type {
	CreateMutationOptions,
	CreateMutationResult,
	CreateQueryOptions,
	CreateQueryResult,
	DataTag,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey
} from '@tanstack/svelte-query';

import type {
	BodyLoginLoginAccessToken,
	HTTPValidationError,
	ItemCreate,
	ItemPublic,
	ItemUpdate,
	ItemsPublic,
	ItemsReadItemsParams,
	Message,
	NewPassword,
	PrivateUserCreate,
	Token,
	UpdatePassword,
	UserCreate,
	UserPublic,
	UserRegister,
	UserUpdate,
	UserUpdateMe,
	UsersPublic,
	UsersReadUsersParams,
	UtilsTestEmailParams
} from './schemas';

import { clientWrapper } from './client-wrapper';
/**
 * OAuth2 compatible token login, get an access token for future requests
 * @summary Login Access Token
 */
export const loginLoginAccessToken = (
	bodyLoginLoginAccessToken: BodyLoginLoginAccessToken,
	signal?: AbortSignal
) => {
	const formUrlEncoded = new URLSearchParams();
	if (
		bodyLoginLoginAccessToken.grant_type !== undefined &&
		bodyLoginLoginAccessToken.grant_type !== null
	) {
		formUrlEncoded.append(`grant_type`, bodyLoginLoginAccessToken.grant_type);
	}
	formUrlEncoded.append(`username`, bodyLoginLoginAccessToken.username);
	formUrlEncoded.append(`password`, bodyLoginLoginAccessToken.password);
	if (bodyLoginLoginAccessToken.scope !== undefined) {
		formUrlEncoded.append(`scope`, bodyLoginLoginAccessToken.scope);
	}
	if (
		bodyLoginLoginAccessToken.client_id !== undefined &&
		bodyLoginLoginAccessToken.client_id !== null
	) {
		formUrlEncoded.append(`client_id`, bodyLoginLoginAccessToken.client_id);
	}
	if (
		bodyLoginLoginAccessToken.client_secret !== undefined &&
		bodyLoginLoginAccessToken.client_secret !== null
	) {
		formUrlEncoded.append(`client_secret`, bodyLoginLoginAccessToken.client_secret);
	}

	return clientWrapper<Token>({
		url: `/api/v1/login/access-token`,
		method: 'POST',
		headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
		data: formUrlEncoded,
		signal
	});
};

export const getLoginLoginAccessTokenMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof loginLoginAccessToken>>,
		TError,
		{ data: BodyLoginLoginAccessToken },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof loginLoginAccessToken>>,
	TError,
	{ data: BodyLoginLoginAccessToken },
	TContext
> => {
	const mutationKey = ['loginLoginAccessToken'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof loginLoginAccessToken>>,
		{ data: BodyLoginLoginAccessToken }
	> = (props) => {
		const { data } = props ?? {};

		return loginLoginAccessToken(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginLoginAccessTokenMutationResult = NonNullable<
	Awaited<ReturnType<typeof loginLoginAccessToken>>
>;
export type LoginLoginAccessTokenMutationBody = BodyLoginLoginAccessToken;
export type LoginLoginAccessTokenMutationError = HTTPValidationError;

/**
 * @summary Login Access Token
 */
export const createLoginLoginAccessToken = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof loginLoginAccessToken>>,
			TError,
			{ data: BodyLoginLoginAccessToken },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof loginLoginAccessToken>>,
	TError,
	{ data: BodyLoginLoginAccessToken },
	TContext
> => {
	const mutationOptions = getLoginLoginAccessTokenMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Test access token
 * @summary Test Token
 */
export const loginTestToken = (signal?: AbortSignal) => {
	return clientWrapper<UserPublic>({ url: `/api/v1/login/test-token`, method: 'POST', signal });
};

export const getLoginTestTokenMutationOptions = <TError = unknown, TContext = unknown>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof loginTestToken>>,
		TError,
		void,
		TContext
	>;
}): CreateMutationOptions<Awaited<ReturnType<typeof loginTestToken>>, TError, void, TContext> => {
	const mutationKey = ['loginTestToken'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginTestToken>>, void> = () => {
		return loginTestToken();
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginTestTokenMutationResult = NonNullable<Awaited<ReturnType<typeof loginTestToken>>>;

export type LoginTestTokenMutationError = unknown;

/**
 * @summary Test Token
 */
export const createLoginTestToken = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof loginTestToken>>,
			TError,
			void,
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof loginTestToken>>, TError, void, TContext> => {
	const mutationOptions = getLoginTestTokenMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Password Recovery
 * @summary Recover Password
 */
export const loginRecoverPassword = (email: string, signal?: AbortSignal) => {
	return clientWrapper<Message>({
		url: `/api/v1/password-recovery/${email}`,
		method: 'POST',
		signal
	});
};

export const getLoginRecoverPasswordMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof loginRecoverPassword>>,
		TError,
		{ email: string },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof loginRecoverPassword>>,
	TError,
	{ email: string },
	TContext
> => {
	const mutationKey = ['loginRecoverPassword'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof loginRecoverPassword>>,
		{ email: string }
	> = (props) => {
		const { email } = props ?? {};

		return loginRecoverPassword(email);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginRecoverPasswordMutationResult = NonNullable<
	Awaited<ReturnType<typeof loginRecoverPassword>>
>;

export type LoginRecoverPasswordMutationError = HTTPValidationError;

/**
 * @summary Recover Password
 */
export const createLoginRecoverPassword = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof loginRecoverPassword>>,
			TError,
			{ email: string },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof loginRecoverPassword>>,
	TError,
	{ email: string },
	TContext
> => {
	const mutationOptions = getLoginRecoverPasswordMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Reset password
 * @summary Reset Password
 */
export const loginResetPassword = (newPassword: NewPassword, signal?: AbortSignal) => {
	return clientWrapper<Message>({
		url: `/api/v1/reset-password/`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: newPassword,
		signal
	});
};

export const getLoginResetPasswordMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof loginResetPassword>>,
		TError,
		{ data: NewPassword },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof loginResetPassword>>,
	TError,
	{ data: NewPassword },
	TContext
> => {
	const mutationKey = ['loginResetPassword'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof loginResetPassword>>,
		{ data: NewPassword }
	> = (props) => {
		const { data } = props ?? {};

		return loginResetPassword(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginResetPasswordMutationResult = NonNullable<
	Awaited<ReturnType<typeof loginResetPassword>>
>;
export type LoginResetPasswordMutationBody = NewPassword;
export type LoginResetPasswordMutationError = HTTPValidationError;

/**
 * @summary Reset Password
 */
export const createLoginResetPassword = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof loginResetPassword>>,
			TError,
			{ data: NewPassword },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof loginResetPassword>>,
	TError,
	{ data: NewPassword },
	TContext
> => {
	const mutationOptions = getLoginResetPasswordMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * HTML Content for Password Recovery
 * @summary Recover Password Html Content
 */
export const loginRecoverPasswordHtmlContent = (email: string, signal?: AbortSignal) => {
	return clientWrapper<string>({
		url: `/api/v1/password-recovery-html-content/${email}`,
		method: 'POST',
		signal
	});
};

export const getLoginRecoverPasswordHtmlContentMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>,
		TError,
		{ email: string },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>,
	TError,
	{ email: string },
	TContext
> => {
	const mutationKey = ['loginRecoverPasswordHtmlContent'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>,
		{ email: string }
	> = (props) => {
		const { email } = props ?? {};

		return loginRecoverPasswordHtmlContent(email);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoginRecoverPasswordHtmlContentMutationResult = NonNullable<
	Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>
>;

export type LoginRecoverPasswordHtmlContentMutationError = HTTPValidationError;

/**
 * @summary Recover Password Html Content
 */
export const createLoginRecoverPasswordHtmlContent = <
	TError = HTTPValidationError,
	TContext = unknown
>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>,
			TError,
			{ email: string },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>,
	TError,
	{ email: string },
	TContext
> => {
	const mutationOptions = getLoginRecoverPasswordHtmlContentMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Retrieve users.
 * @summary Read Users
 */
export const usersReadUsers = (params?: UsersReadUsersParams, signal?: AbortSignal) => {
	return clientWrapper<UsersPublic>({ url: `/api/v1/users/`, method: 'GET', params, signal });
};

export const getUsersReadUsersQueryKey = (params?: UsersReadUsersParams) => {
	return [`/api/v1/users/`, ...(params ? [params] : [])] as const;
};

export const getUsersReadUsersQueryOptions = <
	TData = Awaited<ReturnType<typeof usersReadUsers>>,
	TError = HTTPValidationError
>(
	params?: UsersReadUsersParams,
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData>>;
	}
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUsersReadUsersQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof usersReadUsers>>> = ({ signal }) =>
		usersReadUsers(params, signal);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof usersReadUsers>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersReadUsersQueryResult = NonNullable<Awaited<ReturnType<typeof usersReadUsers>>>;
export type UsersReadUsersQueryError = HTTPValidationError;

/**
 * @summary Read Users
 */

export function createUsersReadUsers<
	TData = Awaited<ReturnType<typeof usersReadUsers>>,
	TError = HTTPValidationError
>(
	params?: UsersReadUsersParams,
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData>>;
	},
	queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getUsersReadUsersQueryOptions(params, options);

	const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Create new user.
 * @summary Create User
 */
export const usersCreateUser = (userCreate: UserCreate, signal?: AbortSignal) => {
	return clientWrapper<UserPublic>({
		url: `/api/v1/users/`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: userCreate,
		signal
	});
};

export const getUsersCreateUserMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersCreateUser>>,
		TError,
		{ data: UserCreate },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersCreateUser>>,
	TError,
	{ data: UserCreate },
	TContext
> => {
	const mutationKey = ['usersCreateUser'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof usersCreateUser>>,
		{ data: UserCreate }
	> = (props) => {
		const { data } = props ?? {};

		return usersCreateUser(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersCreateUserMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersCreateUser>>
>;
export type UsersCreateUserMutationBody = UserCreate;
export type UsersCreateUserMutationError = HTTPValidationError;

/**
 * @summary Create User
 */
export const createUsersCreateUser = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof usersCreateUser>>,
			TError,
			{ data: UserCreate },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof usersCreateUser>>,
	TError,
	{ data: UserCreate },
	TContext
> => {
	const mutationOptions = getUsersCreateUserMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Get current user.
 * @summary Read User Me
 */
export const usersReadUserMe = (signal?: AbortSignal) => {
	return clientWrapper<UserPublic>({ url: `/api/v1/users/me`, method: 'GET', signal });
};

export const getUsersReadUserMeQueryKey = () => {
	return [`/api/v1/users/me`] as const;
};

export const getUsersReadUserMeQueryOptions = <
	TData = Awaited<ReturnType<typeof usersReadUserMe>>,
	TError = unknown
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUsersReadUserMeQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof usersReadUserMe>>> = ({ signal }) =>
		usersReadUserMe(signal);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof usersReadUserMe>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersReadUserMeQueryResult = NonNullable<Awaited<ReturnType<typeof usersReadUserMe>>>;
export type UsersReadUserMeQueryError = unknown;

/**
 * @summary Read User Me
 */

export function createUsersReadUserMe<
	TData = Awaited<ReturnType<typeof usersReadUserMe>>,
	TError = unknown
>(
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData>>;
	},
	queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getUsersReadUserMeQueryOptions(options);

	const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Delete own user.
 * @summary Delete User Me
 */
export const usersDeleteUserMe = () => {
	return clientWrapper<Message>({ url: `/api/v1/users/me`, method: 'DELETE' });
};

export const getUsersDeleteUserMeMutationOptions = <
	TError = unknown,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersDeleteUserMe>>,
		TError,
		void,
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersDeleteUserMe>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ['usersDeleteUserMe'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUserMe>>, void> = () => {
		return usersDeleteUserMe();
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersDeleteUserMeMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersDeleteUserMe>>
>;

export type UsersDeleteUserMeMutationError = unknown;

/**
 * @summary Delete User Me
 */
export const createUsersDeleteUserMe = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof usersDeleteUserMe>>,
			TError,
			void,
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<Awaited<ReturnType<typeof usersDeleteUserMe>>, TError, void, TContext> => {
	const mutationOptions = getUsersDeleteUserMeMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Update own user.
 * @summary Update User Me
 */
export const usersUpdateUserMe = (userUpdateMe: UserUpdateMe) => {
	return clientWrapper<UserPublic>({
		url: `/api/v1/users/me`,
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		data: userUpdateMe
	});
};

export const getUsersUpdateUserMeMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersUpdateUserMe>>,
		TError,
		{ data: UserUpdateMe },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersUpdateUserMe>>,
	TError,
	{ data: UserUpdateMe },
	TContext
> => {
	const mutationKey = ['usersUpdateUserMe'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof usersUpdateUserMe>>,
		{ data: UserUpdateMe }
	> = (props) => {
		const { data } = props ?? {};

		return usersUpdateUserMe(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersUpdateUserMeMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersUpdateUserMe>>
>;
export type UsersUpdateUserMeMutationBody = UserUpdateMe;
export type UsersUpdateUserMeMutationError = HTTPValidationError;

/**
 * @summary Update User Me
 */
export const createUsersUpdateUserMe = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof usersUpdateUserMe>>,
			TError,
			{ data: UserUpdateMe },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof usersUpdateUserMe>>,
	TError,
	{ data: UserUpdateMe },
	TContext
> => {
	const mutationOptions = getUsersUpdateUserMeMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Update own password.
 * @summary Update Password Me
 */
export const usersUpdatePasswordMe = (updatePassword: UpdatePassword) => {
	return clientWrapper<Message>({
		url: `/api/v1/users/me/password`,
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		data: updatePassword
	});
};

export const getUsersUpdatePasswordMeMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersUpdatePasswordMe>>,
		TError,
		{ data: UpdatePassword },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersUpdatePasswordMe>>,
	TError,
	{ data: UpdatePassword },
	TContext
> => {
	const mutationKey = ['usersUpdatePasswordMe'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof usersUpdatePasswordMe>>,
		{ data: UpdatePassword }
	> = (props) => {
		const { data } = props ?? {};

		return usersUpdatePasswordMe(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersUpdatePasswordMeMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersUpdatePasswordMe>>
>;
export type UsersUpdatePasswordMeMutationBody = UpdatePassword;
export type UsersUpdatePasswordMeMutationError = HTTPValidationError;

/**
 * @summary Update Password Me
 */
export const createUsersUpdatePasswordMe = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof usersUpdatePasswordMe>>,
			TError,
			{ data: UpdatePassword },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof usersUpdatePasswordMe>>,
	TError,
	{ data: UpdatePassword },
	TContext
> => {
	const mutationOptions = getUsersUpdatePasswordMeMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Create new user without the need to be logged in.
 * @summary Register User
 */
export const usersRegisterUser = (userRegister: UserRegister, signal?: AbortSignal) => {
	return clientWrapper<UserPublic>({
		url: `/api/v1/users/signup`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: userRegister,
		signal
	});
};

export const getUsersRegisterUserMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersRegisterUser>>,
		TError,
		{ data: UserRegister },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersRegisterUser>>,
	TError,
	{ data: UserRegister },
	TContext
> => {
	const mutationKey = ['usersRegisterUser'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof usersRegisterUser>>,
		{ data: UserRegister }
	> = (props) => {
		const { data } = props ?? {};

		return usersRegisterUser(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersRegisterUserMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersRegisterUser>>
>;
export type UsersRegisterUserMutationBody = UserRegister;
export type UsersRegisterUserMutationError = HTTPValidationError;

/**
 * @summary Register User
 */
export const createUsersRegisterUser = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof usersRegisterUser>>,
			TError,
			{ data: UserRegister },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof usersRegisterUser>>,
	TError,
	{ data: UserRegister },
	TContext
> => {
	const mutationOptions = getUsersRegisterUserMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Get a specific user by id.
 * @summary Read User By Id
 */
export const usersReadUserById = (userId: string, signal?: AbortSignal) => {
	return clientWrapper<UserPublic>({ url: `/api/v1/users/${userId}`, method: 'GET', signal });
};

export const getUsersReadUserByIdQueryKey = (userId: string) => {
	return [`/api/v1/users/${userId}`] as const;
};

export const getUsersReadUserByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof usersReadUserById>>,
	TError = HTTPValidationError
>(
	userId: string,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData>
		>;
	}
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUsersReadUserByIdQueryKey(userId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof usersReadUserById>>> = ({ signal }) =>
		usersReadUserById(userId, signal);

	return { queryKey, queryFn, enabled: !!userId, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof usersReadUserById>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UsersReadUserByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof usersReadUserById>>
>;
export type UsersReadUserByIdQueryError = HTTPValidationError;

/**
 * @summary Read User By Id
 */

export function createUsersReadUserById<
	TData = Awaited<ReturnType<typeof usersReadUserById>>,
	TError = HTTPValidationError
>(
	userId: string,
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData>
		>;
	},
	queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getUsersReadUserByIdQueryOptions(userId, options);

	const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Update a user.
 * @summary Update User
 */
export const usersUpdateUser = (userId: string, userUpdate: UserUpdate) => {
	return clientWrapper<UserPublic>({
		url: `/api/v1/users/${userId}`,
		method: 'PATCH',
		headers: { 'Content-Type': 'application/json' },
		data: userUpdate
	});
};

export const getUsersUpdateUserMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersUpdateUser>>,
		TError,
		{ userId: string; data: UserUpdate },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersUpdateUser>>,
	TError,
	{ userId: string; data: UserUpdate },
	TContext
> => {
	const mutationKey = ['usersUpdateUser'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof usersUpdateUser>>,
		{ userId: string; data: UserUpdate }
	> = (props) => {
		const { userId, data } = props ?? {};

		return usersUpdateUser(userId, data);
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersUpdateUserMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersUpdateUser>>
>;
export type UsersUpdateUserMutationBody = UserUpdate;
export type UsersUpdateUserMutationError = HTTPValidationError;

/**
 * @summary Update User
 */
export const createUsersUpdateUser = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof usersUpdateUser>>,
			TError,
			{ userId: string; data: UserUpdate },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof usersUpdateUser>>,
	TError,
	{ userId: string; data: UserUpdate },
	TContext
> => {
	const mutationOptions = getUsersUpdateUserMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Delete a user.
 * @summary Delete User
 */
export const usersDeleteUser = (userId: string) => {
	return clientWrapper<Message>({ url: `/api/v1/users/${userId}`, method: 'DELETE' });
};

export const getUsersDeleteUserMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof usersDeleteUser>>,
		TError,
		{ userId: string },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof usersDeleteUser>>,
	TError,
	{ userId: string },
	TContext
> => {
	const mutationKey = ['usersDeleteUser'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof usersDeleteUser>>,
		{ userId: string }
	> = (props) => {
		const { userId } = props ?? {};

		return usersDeleteUser(userId);
	};

	return { mutationFn, ...mutationOptions };
};

export type UsersDeleteUserMutationResult = NonNullable<
	Awaited<ReturnType<typeof usersDeleteUser>>
>;

export type UsersDeleteUserMutationError = HTTPValidationError;

/**
 * @summary Delete User
 */
export const createUsersDeleteUser = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof usersDeleteUser>>,
			TError,
			{ userId: string },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof usersDeleteUser>>,
	TError,
	{ userId: string },
	TContext
> => {
	const mutationOptions = getUsersDeleteUserMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Test emails.
 * @summary Test Email
 */
export const utilsTestEmail = (params: UtilsTestEmailParams, signal?: AbortSignal) => {
	return clientWrapper<Message>({
		url: `/api/v1/utils/test-email/`,
		method: 'POST',
		params,
		signal
	});
};

export const getUtilsTestEmailMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof utilsTestEmail>>,
		TError,
		{ params: UtilsTestEmailParams },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof utilsTestEmail>>,
	TError,
	{ params: UtilsTestEmailParams },
	TContext
> => {
	const mutationKey = ['utilsTestEmail'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof utilsTestEmail>>,
		{ params: UtilsTestEmailParams }
	> = (props) => {
		const { params } = props ?? {};

		return utilsTestEmail(params);
	};

	return { mutationFn, ...mutationOptions };
};

export type UtilsTestEmailMutationResult = NonNullable<Awaited<ReturnType<typeof utilsTestEmail>>>;

export type UtilsTestEmailMutationError = HTTPValidationError;

/**
 * @summary Test Email
 */
export const createUtilsTestEmail = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof utilsTestEmail>>,
			TError,
			{ params: UtilsTestEmailParams },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof utilsTestEmail>>,
	TError,
	{ params: UtilsTestEmailParams },
	TContext
> => {
	const mutationOptions = getUtilsTestEmailMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * @summary Health Check
 */
export const utilsHealthCheck = (signal?: AbortSignal) => {
	return clientWrapper<boolean>({ url: `/api/v1/utils/health-check/`, method: 'GET', signal });
};

export const getUtilsHealthCheckQueryKey = () => {
	return [`/api/v1/utils/health-check/`] as const;
};

export const getUtilsHealthCheckQueryOptions = <
	TData = Awaited<ReturnType<typeof utilsHealthCheck>>,
	TError = unknown
>(options?: {
	query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof utilsHealthCheck>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getUtilsHealthCheckQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof utilsHealthCheck>>> = ({ signal }) =>
		utilsHealthCheck(signal);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof utilsHealthCheck>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type UtilsHealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof utilsHealthCheck>>>;
export type UtilsHealthCheckQueryError = unknown;

/**
 * @summary Health Check
 */

export function createUtilsHealthCheck<
	TData = Awaited<ReturnType<typeof utilsHealthCheck>>,
	TError = unknown
>(
	options?: {
		query?: Partial<
			CreateQueryOptions<Awaited<ReturnType<typeof utilsHealthCheck>>, TError, TData>
		>;
	},
	queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getUtilsHealthCheckQueryOptions(options);

	const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Retrieve items.
 * @summary Read Items
 */
export const itemsReadItems = (params?: ItemsReadItemsParams, signal?: AbortSignal) => {
	return clientWrapper<ItemsPublic>({ url: `/api/v1/items/`, method: 'GET', params, signal });
};

export const getItemsReadItemsQueryKey = (params?: ItemsReadItemsParams) => {
	return [`/api/v1/items/`, ...(params ? [params] : [])] as const;
};

export const getItemsReadItemsQueryOptions = <
	TData = Awaited<ReturnType<typeof itemsReadItems>>,
	TError = HTTPValidationError
>(
	params?: ItemsReadItemsParams,
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof itemsReadItems>>, TError, TData>>;
	}
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getItemsReadItemsQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof itemsReadItems>>> = ({ signal }) =>
		itemsReadItems(params, signal);

	return { queryKey, queryFn, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof itemsReadItems>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemsReadItemsQueryResult = NonNullable<Awaited<ReturnType<typeof itemsReadItems>>>;
export type ItemsReadItemsQueryError = HTTPValidationError;

/**
 * @summary Read Items
 */

export function createItemsReadItems<
	TData = Awaited<ReturnType<typeof itemsReadItems>>,
	TError = HTTPValidationError
>(
	params?: ItemsReadItemsParams,
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof itemsReadItems>>, TError, TData>>;
	},
	queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getItemsReadItemsQueryOptions(params, options);

	const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Create new item.
 * @summary Create Item
 */
export const itemsCreateItem = (itemCreate: ItemCreate, signal?: AbortSignal) => {
	return clientWrapper<ItemPublic>({
		url: `/api/v1/items/`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: itemCreate,
		signal
	});
};

export const getItemsCreateItemMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof itemsCreateItem>>,
		TError,
		{ data: ItemCreate },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof itemsCreateItem>>,
	TError,
	{ data: ItemCreate },
	TContext
> => {
	const mutationKey = ['itemsCreateItem'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof itemsCreateItem>>,
		{ data: ItemCreate }
	> = (props) => {
		const { data } = props ?? {};

		return itemsCreateItem(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type ItemsCreateItemMutationResult = NonNullable<
	Awaited<ReturnType<typeof itemsCreateItem>>
>;
export type ItemsCreateItemMutationBody = ItemCreate;
export type ItemsCreateItemMutationError = HTTPValidationError;

/**
 * @summary Create Item
 */
export const createItemsCreateItem = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof itemsCreateItem>>,
			TError,
			{ data: ItemCreate },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof itemsCreateItem>>,
	TError,
	{ data: ItemCreate },
	TContext
> => {
	const mutationOptions = getItemsCreateItemMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Get item by ID.
 * @summary Read Item
 */
export const itemsReadItem = (id: string, signal?: AbortSignal) => {
	return clientWrapper<ItemPublic>({ url: `/api/v1/items/${id}`, method: 'GET', signal });
};

export const getItemsReadItemQueryKey = (id: string) => {
	return [`/api/v1/items/${id}`] as const;
};

export const getItemsReadItemQueryOptions = <
	TData = Awaited<ReturnType<typeof itemsReadItem>>,
	TError = HTTPValidationError
>(
	id: string,
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof itemsReadItem>>, TError, TData>>;
	}
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getItemsReadItemQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof itemsReadItem>>> = ({ signal }) =>
		itemsReadItem(id, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as CreateQueryOptions<
		Awaited<ReturnType<typeof itemsReadItem>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ItemsReadItemQueryResult = NonNullable<Awaited<ReturnType<typeof itemsReadItem>>>;
export type ItemsReadItemQueryError = HTTPValidationError;

/**
 * @summary Read Item
 */

export function createItemsReadItem<
	TData = Awaited<ReturnType<typeof itemsReadItem>>,
	TError = HTTPValidationError
>(
	id: string,
	options?: {
		query?: Partial<CreateQueryOptions<Awaited<ReturnType<typeof itemsReadItem>>, TError, TData>>;
	},
	queryClient?: QueryClient
): CreateQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = getItemsReadItemQueryOptions(id, options);

	const query = createQuery(queryOptions, queryClient) as CreateQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Update an item.
 * @summary Update Item
 */
export const itemsUpdateItem = (id: string, itemUpdate: ItemUpdate) => {
	return clientWrapper<ItemPublic>({
		url: `/api/v1/items/${id}`,
		method: 'PUT',
		headers: { 'Content-Type': 'application/json' },
		data: itemUpdate
	});
};

export const getItemsUpdateItemMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof itemsUpdateItem>>,
		TError,
		{ id: string; data: ItemUpdate },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof itemsUpdateItem>>,
	TError,
	{ id: string; data: ItemUpdate },
	TContext
> => {
	const mutationKey = ['itemsUpdateItem'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof itemsUpdateItem>>,
		{ id: string; data: ItemUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return itemsUpdateItem(id, data);
	};

	return { mutationFn, ...mutationOptions };
};

export type ItemsUpdateItemMutationResult = NonNullable<
	Awaited<ReturnType<typeof itemsUpdateItem>>
>;
export type ItemsUpdateItemMutationBody = ItemUpdate;
export type ItemsUpdateItemMutationError = HTTPValidationError;

/**
 * @summary Update Item
 */
export const createItemsUpdateItem = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof itemsUpdateItem>>,
			TError,
			{ id: string; data: ItemUpdate },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof itemsUpdateItem>>,
	TError,
	{ id: string; data: ItemUpdate },
	TContext
> => {
	const mutationOptions = getItemsUpdateItemMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Delete an item.
 * @summary Delete Item
 */
export const itemsDeleteItem = (id: string) => {
	return clientWrapper<Message>({ url: `/api/v1/items/${id}`, method: 'DELETE' });
};

export const getItemsDeleteItemMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof itemsDeleteItem>>,
		TError,
		{ id: string },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof itemsDeleteItem>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ['itemsDeleteItem'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof itemsDeleteItem>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return itemsDeleteItem(id);
	};

	return { mutationFn, ...mutationOptions };
};

export type ItemsDeleteItemMutationResult = NonNullable<
	Awaited<ReturnType<typeof itemsDeleteItem>>
>;

export type ItemsDeleteItemMutationError = HTTPValidationError;

/**
 * @summary Delete Item
 */
export const createItemsDeleteItem = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof itemsDeleteItem>>,
			TError,
			{ id: string },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof itemsDeleteItem>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getItemsDeleteItemMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};

/**
 * Create a new user.
 * @summary Create User
 */
export const privateCreateUser = (privateUserCreate: PrivateUserCreate, signal?: AbortSignal) => {
	return clientWrapper<UserPublic>({
		url: `/api/v1/private/users/`,
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		data: privateUserCreate,
		signal
	});
};

export const getPrivateCreateUserMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown
>(options?: {
	mutation?: CreateMutationOptions<
		Awaited<ReturnType<typeof privateCreateUser>>,
		TError,
		{ data: PrivateUserCreate },
		TContext
	>;
}): CreateMutationOptions<
	Awaited<ReturnType<typeof privateCreateUser>>,
	TError,
	{ data: PrivateUserCreate },
	TContext
> => {
	const mutationKey = ['privateCreateUser'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof privateCreateUser>>,
		{ data: PrivateUserCreate }
	> = (props) => {
		const { data } = props ?? {};

		return privateCreateUser(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type PrivateCreateUserMutationResult = NonNullable<
	Awaited<ReturnType<typeof privateCreateUser>>
>;
export type PrivateCreateUserMutationBody = PrivateUserCreate;
export type PrivateCreateUserMutationError = HTTPValidationError;

/**
 * @summary Create User
 */
export const createPrivateCreateUser = <TError = HTTPValidationError, TContext = unknown>(
	options?: {
		mutation?: CreateMutationOptions<
			Awaited<ReturnType<typeof privateCreateUser>>,
			TError,
			{ data: PrivateUserCreate },
			TContext
		>;
	},
	queryClient?: QueryClient
): CreateMutationResult<
	Awaited<ReturnType<typeof privateCreateUser>>,
	TError,
	{ data: PrivateUserCreate },
	TContext
> => {
	const mutationOptions = getPrivateCreateUserMutationOptions(options);

	return createMutation(mutationOptions, queryClient);
};
